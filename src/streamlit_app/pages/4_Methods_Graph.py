import streamlit as st
import json
import pandas as pd
from pyvis.network import Network
import os
import logging
from datetime import datetime

# --- Configuration ---
# Path to your generated graph data JSON file
# Adjust this path if your data/methods directory is not directly relative to where Streamlit is run
GRAPH_DATA_JSON_PATH = "./data/methods/graph_data.json"
# Path for the temporary HTML file generated by pyvis
TEMP_HTML_PATH = "./graph_visualization_methods.html" # Use a distinct name for this page's temp file

# --- Logging Setup ---
# Ensure logs directory exists
LOG_DIR = "./data/logs"
os.makedirs(LOG_DIR, exist_ok=True)
log_filename = datetime.now().strftime(f"{LOG_DIR}/methods_graph_page_%Y%m%d_%H%M%S.log")

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Clear existing handlers to prevent duplicate logs in Streamlit re-runs
# This is important for pages in a multi-page app
if logger.handlers:
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

file_handler = logging.FileHandler(log_filename)
file_handler.setLevel(logging.INFO)
console_handler = st.empty() # Use st.empty() for console output in Streamlit
console_handler.empty() # Clear previous console output

formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)
# console_handler.setFormatter(formatter) # st.empty() doesn't use a formatter directly

logger.addHandler(file_handler)
# logger.addHandler(console_handler) # Don't add st.empty() as a handler directly

# --- Function to Load Graph Data ---
@st.cache_data # Cache the data loading to improve performance on re-runs
def load_graph_data(file_path):
    """Loads graph data from a JSON file."""
    if not os.path.exists(file_path):
        logger.error(f"Graph data file not found at: {file_path}")
        st.error(f"Graph data file not found. Please ensure '{file_path}' exists.")
        return None, None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        logger.info(f"Successfully loaded graph data from '{file_path}'.")
        return data['nodes'], data['links']
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding JSON from '{file_path}': {e}")
        st.error(f"Error loading graph data: Invalid JSON format. {e}")
        return None, None
    except Exception as e:
        logger.error(f"An unexpected error occurred while loading graph data: {e}")
        st.error(f"An unexpected error occurred while loading graph data: {e}")
        return None, None

# --- Main Streamlit Page Content ---
def app():
    st.set_page_config(layout="wide", page_title="Computational Neuroscience Methods Graph")

    st.title("Interactive Graph of Computational Neuroscience Methods")
    st.markdown("""
    This interactive graph visualizes connections between computational neuroscience papers based on their semantic similarity.
    Use the sidebar to search for papers and filter the graph. Click on nodes to see paper details.
    """)

    nodes, links = load_graph_data(GRAPH_DATA_JSON_PATH)

    if nodes is None or links is None:
        st.stop() # Stop the app if data loading failed

    # Convert nodes to a DataFrame for easier filtering
    df_nodes = pd.DataFrame(nodes)
    df_links = pd.DataFrame(links)

    # --- Sidebar for Search and Filters ---
    st.sidebar.header("Search & Filters")

    # Search by Title or Authors
    search_query = st.sidebar.text_input("Search by Title or Authors", "")

    # Filter by Year
    min_year = int(df_nodes['year'].min()) if 'year' in df_nodes.columns and df_nodes['year'].notna().any() else 1900
    max_year = int(df_nodes['year'].max()) if 'year' in df_nodes.columns and df_nodes['year'].notna().any() else datetime.now().year
    year_range = st.sidebar.slider(
        "Filter by Year",
        min_value=min_year,
        max_value=max_year,
        value=(min_year, max_year)
    )

    # Filter by Paper Type (if 'kw_paper_type' exists)
    selected_paper_types = []
    if 'kw_paper_type' in df_nodes.columns:
        all_paper_types = df_nodes['kw_paper_type'].dropna().unique().tolist()
        if all_paper_types:
            selected_paper_types = st.sidebar.multiselect(
                "Filter by Paper Type",
                options=all_paper_types,
                default=all_paper_types # Select all by default
            )

    # Filter by Pipeline Category (if 'kw_pipeline_category' exists)
    selected_pipeline_categories = []
    if 'kw_pipeline_category' in df_nodes.columns:
        all_pipeline_categories = df_nodes['kw_pipeline_category'].dropna().unique().tolist()
        if all_pipeline_categories:
            selected_pipeline_categories = st.sidebar.multiselect(
                "Filter by Pipeline Category",
                options=all_pipeline_categories,
                default=all_pipeline_categories # Select all by default
            )

    # Apply filters
    filtered_nodes_df = df_nodes.copy()

    if search_query:
        filtered_nodes_df = filtered_nodes_df[
            filtered_nodes_df['title'].str.contains(search_query, case=False, na=False) |
            filtered_nodes_df['authors'].str.contains(search_query, case=False, na=False)
        ]

    if 'year' in filtered_nodes_df.columns:
        filtered_nodes_df = filtered_nodes_df[
            (filtered_nodes_df['year'] >= year_range[0]) &
            (filtered_nodes_df['year'] <= year_range[1])
        ]

    if selected_paper_types and 'kw_paper_type' in filtered_nodes_df.columns:
        filtered_nodes_df = filtered_nodes_df[
            filtered_nodes_df['kw_paper_type'].isin(selected_paper_types)
        ]

    if selected_pipeline_categories and 'kw_pipeline_category' in filtered_nodes_df.columns:
        filtered_nodes_df = filtered_nodes_df[
            filtered_nodes_df['kw_pipeline_category'].isin(selected_pipeline_categories)
        ]

    # Get the IDs of the filtered nodes
    filtered_node_ids = set(filtered_nodes_df['id'].tolist())

    # Filter links to only include those between visible nodes
    filtered_links_df = df_links[
        (df_links['source'].isin(filtered_node_ids)) &
        (df_links['target'].isin(filtered_node_ids))
    ]

    st.sidebar.info(f"Showing {len(filtered_node_ids)} papers and {len(filtered_links_df)} connections.")

    # --- Graph Visualization ---
    st.subheader("Graph Visualization")

    if not filtered_nodes_df.empty:
        # Create a pyvis network object
        net = Network(
            height="750px",
            width="100%",
            bgcolor="#222222",
            font_color="white",
            notebook=True, # Important for Streamlit to render correctly
            cdn_resources='remote' # Use remote CDN for resources
        )

        # Configure physics for better layout
        net.toggle_physics(True)
        net.repulsion(node_distance=150, central_gravity=0.2, spring_length=200, spring_strength=0.05, damping=0.09)

        # Add nodes to the network
        for _, node in filtered_nodes_df.iterrows():
            # Customize node appearance based on properties
            title_html = f"""
            <b>Title:</b> {node['title']}<br>
            <b>Authors:</b> {node['authors']}<br>
            <b>Year:</b> {node['year']}<br>
            <b>Journal:</b> {node['journal']}<br>
            <b>Paper Type:</b> {node.get('kw_paper_type', 'N/A')}<br>
            <b>Pipeline Category:</b> {node.get('kw_pipeline_category', 'N/A')}<br>
            <b>DOI:</b> <a href="https://doi.org/{node['id']}" target="_blank">{node['id']}</a><br>
            """
            # Add a tooltip for hovering
            tooltip = f"{node['title']} ({node['year']})"

            # Example of dynamic node sizing/coloring (adjust as needed)
            size = 10 + (node['year'] - min_year) / (max_year - min_year + 1) * 15 if (max_year - min_year) > 0 else 15
            color = "#FF6347" if node.get('kw_paper_type') == 'Review' else "#6A5ACD" # Example: different color for review papers

            net.add_node(
                node['id'],
                label=node['title'], # What's displayed on the node
                title=title_html,    # HTML content for the tooltip
                x=node['x'] * 1000,  # Scale coordinates for better visualization if needed
                y=node['y'] * 1000,
                size=size,
                color=color,
                # Add other attributes that you might want to use for styling or interaction
                # These will be available in JavaScript if you inspect the network object
                paper_data=node.to_dict() # Pass the entire node data for easy access in JS
            )

        # Add edges to the network
        for _, link in filtered_links_df.iterrows():
            net.add_edge(
                link['source'],
                link['target'],
                value=link['value'], # Can be used for edge thickness
                title=f"Similarity: {link['value']:.2f}", # Tooltip for edge
                color="#888888" # Edge color
            )

        # Enable interaction
        net.show_buttons(filter_=['physics', 'selection', 'nodes', 'edges', 'manipulation'])
        net.options.interaction.hover = True
        net.options.interaction.tooltipDelay = 300
        net.options.interaction.zoomView = True
        net.options.interaction.dragNodes = True
        net.options.interaction.dragView = True

        # Save the network to an HTML file
        net.save_graph(TEMP_HTML_PATH)

        # Display the HTML file in Streamlit
        with open(TEMP_HTML_PATH, 'r', encoding='utf-8') as f:
            html_content = f.read()
        st.components.v1.html(html_content, height=750, scrolling=True)

        # --- Node Details Display ---
        st.subheader("Selected Paper Details")
        st.info("Click on a node in the graph to see its details here (requires custom component for direct interaction). "
                "Hover over nodes for quick details.")

    else:
        st.warning("No papers match the current filters. Adjust your search or filters.")

    # Clean up the temporary HTML file after display (optional, but good practice)
    if os.path.exists(TEMP_HTML_PATH):
        os.remove(TEMP_HTML_PATH)
        logger.info(f"Cleaned up temporary HTML file: {TEMP_HTML_PATH}")

    st.markdown("---")
    st.markdown("Developed for Computational Neuroscience Paper Review")

# This ensures that when Streamlit runs `Methods_Graph.py` as a page,
# the `app()` function is called.
if __name__ == "__main__":
    app()
